{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/crypto.ts", "../../src/types.ts"],
  "sourcesContent": ["import * as WebBrowser from 'expo-web-browser';\nimport { Extension } from '@magic-sdk/react-native';\nimport { createCryptoChallenge } from './crypto';\nimport {\n  OAuthErrorData,\n  OAuthPayloadMethods,\n  OAuthRedirectConfiguration,\n  OAuthRedirectError,\n  OAuthRedirectResult,\n} from './types';\n\nexport class OAuthExtension extends Extension.Internal<'oauth'> {\n  name = 'oauth' as const;\n  config = {};\n  compat = {\n    'magic-sdk': false,\n    '@magic-sdk/react-native': '>=2.7.0',\n  };\n\n  public loginWithPopup(configuration: OAuthRedirectConfiguration) {\n    return this.utils.createPromiEvent<OAuthRedirectResult>(async (resolve, reject) => {\n      try {\n        const { provider, query, redirectURI } = await createURI.call(this, configuration);\n        const url = `https://auth.magic.link/v1/oauth2/${provider}/start?${query}`;\n\n        /**\n         * Response Type\n         * https://docs.expo.io/versions/latest/sdk/webbrowser/#returns\n         */\n        const res = await WebBrowser.openAuthSessionAsync(url, redirectURI);\n\n        if (res.type === 'success') {\n          const queryString = new URL(res.url).search;\n\n          resolve(getResult.call(this, queryString.toString()));\n        } else {\n          reject(this.createError<object>(res.type, 'User has cancelled the authentication', {}));\n        }\n      } catch (err: any) {\n        reject(\n          this.createError<object>(err.message, 'An error has occurred', {\n            err,\n          }),\n        );\n      }\n    });\n  }\n}\n\nconst OAUTH_REDIRECT_METADATA_KEY = 'oauth_redirect_metadata';\n\nexport async function createURI(this: OAuthExtension, configuration: OAuthRedirectConfiguration) {\n  // Bust any old, in-progress OAuth flows.\n  await this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n  // Unpack configuration, generate crypto values, and persist to storage.\n  const { provider, redirectURI, scope, loginHint } = configuration;\n  const { verifier, challenge, state } = await createCryptoChallenge();\n\n  /* Stringify for RN Async storage */\n  const storedData = JSON.stringify({\n    verifier,\n    state,\n  });\n\n  await this.utils.storage.setItem(OAUTH_REDIRECT_METADATA_KEY, storedData);\n\n  // Formulate the initial redirect query to Magic's OAuth hub.\n  // Required fields:\n  //   - `magic_api_key`\n  //   - `magic_challenge`\n  //   - `state`\n  //   - `redirect_uri`\n  //   - `platform`\n\n  const query = [\n    `magic_api_key=${encodeURIComponent(this.sdk.apiKey)}`,\n    `magic_challenge=${encodeURIComponent(challenge)}`,\n    `state=${encodeURIComponent(state)}`,\n    `platform=${encodeURIComponent('rn')}`,\n    scope && `scope=${encodeURIComponent(scope.join(' '))}`,\n    redirectURI && `redirect_uri=${encodeURIComponent(redirectURI)}`,\n    loginHint && `login_hint=${encodeURIComponent(loginHint)}`,\n  ].reduce((prev, next) => (next ? `${prev}&${next}` : prev));\n\n  return {\n    query,\n    provider,\n    redirectURI,\n  };\n}\n\nexport function getResult(this: OAuthExtension, queryString: string) {\n  return this.utils.createPromiEvent<OAuthRedirectResult>(async (resolve, reject) => {\n    const json: string = await this.utils.storage.getItem(OAUTH_REDIRECT_METADATA_KEY);\n\n    const { verifier, state } = JSON.parse(json);\n\n    // Remove the save OAuth state from storage, it stays in memory now...\n    this.utils.storage.removeItem(OAUTH_REDIRECT_METADATA_KEY);\n\n    const parseRedirectResult = this.utils.createJsonRpcRequestPayload(OAuthPayloadMethods.ParseRedirectResult, [\n      queryString,\n      verifier,\n      state,\n    ]);\n\n    // Parse the result, which may contain an OAuth-formatted error.\n    const resultOrError = await this.request<OAuthRedirectResult | OAuthRedirectError>(parseRedirectResult);\n    const maybeResult = resultOrError as OAuthRedirectResult;\n    const maybeError = resultOrError as OAuthRedirectError;\n\n    if (maybeError.error) {\n      reject(\n        this.createError<OAuthErrorData>(maybeError.error, maybeError.error_description ?? 'An error occurred.', {\n          errorURI: maybeError.error_uri,\n          provider: maybeError.provider,\n        }),\n      );\n    }\n\n    resolve(maybeResult);\n  });\n}\n\nexport * from './types';\n", "import { WordArray } from 'crypto-js';\nimport sha256Fallback from 'crypto-js/sha256';\nimport Base64 from 'crypto-js/enc-base64';\n\nconst CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\nconst HAS_CRYPTO = typeof window !== 'undefined' && !!(window.crypto as any);\nconst HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!(window.crypto.subtle as any);\n\n/**\n * Stringifies `bytes` using the OAuth 2.0 `code_verifier` character set.\n */\nfunction bytesToVerifierString(bytes: Uint8Array) {\n  return Array.from(bytes)\n    .map((value: number) => CHARSET[value % CHARSET.length])\n    .join('');\n}\n\n/**\n * Stringifies argument (as CryptoJS `WordArray` or EcmaScript `ArrayBuffer`)\n * and encodes to URL-safe Base64.\n */\nfunction base64URLEncodeFromByteArray(wordArray: WordArray): string;\nfunction base64URLEncodeFromByteArray(arrayBuffer: ArrayBuffer): string;\nfunction base64URLEncodeFromByteArray(arg: WordArray | ArrayBuffer): string {\n  const makeURLSafe = (base64: string) => {\n    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n  };\n\n  if (arg instanceof ArrayBuffer) {\n    const bytes = new Uint8Array(arg);\n    const utf8Binary = Array.from(bytes)\n      .map((value) => String.fromCharCode(value))\n      .join('');\n\n    const base64 = btoa(utf8Binary);\n    return makeURLSafe(base64);\n  }\n\n  return makeURLSafe(Base64.stringify(arg));\n}\n\n/**\n * Produces a SHA-256 hash of the given `message`. This function first attempts\n * to use the browser's built-in `SubtleCrypto` API, falling back to\n * CryptoJS if required.\n */\nasync function sha256(message: string) {\n  if (HAS_SUBTLE_CRYPTO) {\n    const bytes = new TextEncoder().encode(message);\n    return crypto.subtle.digest('SHA-256', bytes).then(base64URLEncodeFromByteArray);\n  }\n\n  return base64URLEncodeFromByteArray(sha256Fallback(message));\n}\n\n/**\n * Creates a cryptographically random string using the browser's built-in\n * `Crypto` API, falling back to `Math.random` if required.\n */\nfunction createRandomString(size: number) {\n  const bytes = new Uint8Array(size);\n\n  if (HAS_CRYPTO) {\n    window.crypto.getRandomValues(bytes);\n  } else {\n    for (let i = 0; i < size; i += 1) bytes[i] = Math.floor(Math.random() * Math.floor(255));\n  }\n\n  return bytesToVerifierString(bytes);\n}\n\n/**\n * Creates OAuth 2.0-compatible `code_verifier`, `code_challenge`, and `state`\n * parameters.\n */\nexport async function createCryptoChallenge() {\n  const state = createRandomString(128);\n  const verifier = createRandomString(128);\n  const challenge = await sha256(verifier);\n  return { verifier, challenge, state };\n}\n", "import { MagicUserMetadata } from '@magic-sdk/types';\n\nexport enum OAuthPayloadMethods {\n  ParseRedirectResult = 'magic_oauth_parse_redirect_result',\n}\n\nexport type OAuthProvider =\n  | 'google'\n  | 'facebook'\n  | 'apple'\n  | 'github'\n  | 'bitbucket'\n  | 'gitlab'\n  | 'linkedin'\n  | 'twitter'\n  | 'discord'\n  | 'twitch'\n  | 'microsoft';\n\nexport interface OAuthErrorData {\n  provider: OAuthProvider;\n  errorURI?: string;\n}\n\nexport interface OpenIDConnectProfile {\n  name?: string;\n  familyName?: string;\n  givenName?: string;\n  middleName?: string;\n  nickname?: string;\n  preferredUsername?: string;\n  profile?: string;\n  picture?: string;\n  website?: string;\n  gender?: string;\n  birthdate?: string;\n  zoneinfo?: string;\n  locale?: string;\n  updatedAt?: number;\n}\n\nexport interface OpenIDConnectEmail {\n  email?: string;\n  emailVerified?: boolean;\n}\n\nexport interface OpenIDConnectPhone {\n  phoneNumber?: string;\n  phoneNumberVerified?: boolean;\n}\n\nexport interface OpenIDConnectAddress {\n  address?: {\n    formatted?: string;\n    streetAddress?: string;\n    locality?: string;\n    region?: string;\n    postalCode?: string;\n    country?: string;\n  };\n}\n\nexport type OpenIDConnectUserInfo = OpenIDConnectProfile &\n  OpenIDConnectEmail &\n  OpenIDConnectPhone &\n  OpenIDConnectAddress & { sub?: string; sources?: Record<string, any> } & Record<string, any>;\n\nexport interface OAuthRedirectResult {\n  oauth: {\n    provider: OAuthProvider;\n    scope: string[];\n    accessToken: string;\n    userHandle: string;\n    userInfo: OpenIDConnectUserInfo;\n  };\n\n  magic: {\n    idToken: string;\n    userMetadata: MagicUserMetadata;\n  };\n}\n\nexport interface OAuthRedirectError {\n  provider: OAuthProvider;\n  error: string;\n  error_description?: string;\n  error_uri?: string;\n}\n\nexport interface OAuthRedirectConfiguration {\n  provider: OAuthProvider;\n  redirectURI: string;\n  scope?: string[];\n  loginHint?: string;\n}\n\nexport enum OAuthErrorCode {\n  InvalidRequest = 'invalid_request',\n  InvalidClient = 'invalid_client',\n  InvalidScope = 'invalid_scope',\n  InvalidGrant = 'invalid_grant',\n  UnauthorizedClient = 'unauthorized_client',\n  UnsupportedResponseType = 'unsupported_response_type',\n  UnsupportedGrantType = 'unsupported_grant_type',\n  UnsupportedTokenType = 'unsupported_token_type',\n  AccessDenied = 'access_denied',\n  ServerError = 'server_error',\n  TemporarilyUnavailable = 'temporarily_unavailable',\n}\n"],
  "mappings": "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",
  "names": []
}
